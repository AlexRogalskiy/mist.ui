<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner.html">

<link rel="import" href="rule-item.html">
<link rel="import" href="rule-edit.html">

<dom-module id="mist-rules">
    <template>
        <style include="shared-styles">
            :host {
                display: block;
            }

            paper-button {
                background-color: transparent !important;
                color: inherit !important;
                padding: 0.8em 1.57em 0.7em 1.57em;
                font-weight: 500;
                background-color: transparent;
            }

            paper-button[disabled] {
                background-color: rgba(0, 0, 0, .13) !important;
                color: rgba(0, 0, 0, 0.32) !important;
            }

            paper-material {
                border-top: 2px solid #ddd;
                padding-bottom: 0;
            }

            paper-button iron-icon {
                opacity: 0.32;
                padding: 4px;
            }

            rule-edit {
                padding: 0 24px 16px 24px;
            }

            .rule-actions {
                justify-content: flex-end;
                font-size: 0.9em;
                margin-top: 16px;
            }

            .errormsg-container {
                color: var(--red-color);
                align-self: flex-start;
                flex: 1;
            }

            .errormsg-container iron-icon {
                color: inherit;
            }
            paper-material > h2.title {
                background-color: #444;
                color: #fff;
                text-transform: capitalize;
                padding: 0 24px;
                margin: 0;
            }
        </style>
        <template is="dom-repeat" items="[[ruleCategories]]" as="cat">
            <paper-material elevation="0">
                <h2 class="title" hidden$="[[_titleHidden(resource,cat,rules)]]">[[cat.name]]</h2>
                <template is="dom-repeat" items="[[_computeResourceRulesArray(rules,resource,cat)]]">
                    <!-- <h2 hidden$="[[resource]]">[[item.selectors.0.ids]]</h2> -->
                    <rule-item hidden$=[[item.editing]] editing={{item.editing}} rule=[[item]] available-metrics=[[availableMetrics]]
                        users=[[users]] teams=[[teams]] open-incident=[[_hasOpenIncident(item,incidents)]]></rule-item>
                    <rule-edit hidden$=[[!item.editing]] active={{item.editing}} current-rule=[[item]] resource=[[resource]] available-metrics=[[availableMetrics]] machines="[[machines]]"
                        users=[[users]] teams=[[teams]]></rule-edit>
                </template>
            </paper-material>
        </template>
        <paper-material elevation="0">
            <paper-button toggles active="{{addingRule}}" hidden$="[[addingRule]]">
                <iron-icon icon="icons:add-circle"></iron-icon> add new rule
            </paper-button>
            <rule-edit active={{addingRule}} available-metrics=[[availableMetrics]] resource=[[resource]] users=[[users]] teams=[[teams]] machines="[[machines]]"
                hidden$=[[!addingRule]]>
            </rule-edit>
        </paper-material>
    </template>

    <script>
RULE_CATEGORIES = [{
    name: 'on all machines',
    type: 'all_machines'
},{
    name: 'on machines with tags',
    type: 'tagged_machines'
},{
    name: 'on specific machines',
    type: 'specific_machines'
}]
        Polymer({
            is: 'mist-rules',

            properties: {
                incidents: {
                    type: Array
                },
                resource: {
                    type: Object, // machine, cloud or other later
                    value: false
                },
                machines: Array,
                rules: Object,
                ruleCategories: {
                    type: Array,
                    computed: 'computeRuleCategories(resource, rules)'
                },
                resourceRules: {
                    type: Array,
                    // computed: '_computeResourceRulesArray(rules.*, resource, category)'
                },
                builtinMetrics: {
                    type: Object
                },
                customMetrics: {
                    type: Object
                },
                availableMetrics: {
                    type: Array,
                    computed: "_computeMetrics(resource, builtinMetrics, customMetrics)"
                },
                addingRule: {
                    type: Boolean,
                    value: false
                },
                teams: Array,
                users: Array
            },
            ready: function () {},
            _computeResourceRulesArray: function (rules, resource, category) {
                var rulesArray = [],
                    that = this;
                if (this.rules) {
                    for (var rule in this.rules) {
                        //this.rules[rule].edit = false;
                        rulesArray.push(this.rules[rule]);
                    }
                }
                if (!this.resource)
                    return rulesArray.filter(function(r){return that._ruleInCategory(r,category)});
                var resourceRules = rulesArray.filter(function (r) {
                    return that._ruleAppliesOnResource(r, resource);
                }).reverse();
                return resourceRules;
            },
            _ruleInCategory: function(r,category) {
                if (category.type == 'specific_machines') {
                    for (var p in r.selectors) {
                        if (r.selectors[p].type == 'machines' && r.selectors[p].ids.length == 1)
                            return true;
                    }
                }
                else if (category.type == 'all_machines') {
                    for (var p in r.selectors) {
                        if (r.selectors[p].type == 'machines' && r.selectors[p].ids.length == 0)
                            return true;
                    }
                }
                else if (category.type == 'tagged_machines') {
                    for (var p in r.selectors) {
                        if (r.selectors[p].type == 'tags')
                            return true;
                    }
                }
                return false;
            },
            _computeNames: function (selectors) {
                var names = "";
                for (var i = 0; i < selectors.length; i++) {
                    if (selectors[i].type == "machines") {
                        for (var j = 0; j < selectors[i].ids.length; i++) {
                            names.push(this.model.machines[selectors[i].ids[j]].name)
                        }
                    }
                }
                return names;
            },
            _titleHidden: function(resource,cat,rules) {
                //hide title if either in resource's single page or if category has no rules
                return resource || this._categoryHasNoRules(rules,cat);
            },
            _categoryHasNoRules: function(rules,category) {
                for (var p in rules) {
                    if (this._ruleInCategory(rules[p], category)) {
                        return false;
                    }
                }
                return true;
            },
            _ruleAppliesOnResource: function (r, resource) {
                var type = 'machines',
                    that = this;
                var m = r.selectors && r.selectors.find(function (c) {
                    return (c.type == type && c.ids.indexOf(that.resource.id) > -1) || (c.type ==
                        'tags' && that._tagsInResource(c.tags, resource))
                });
                return m ? true : false;
            },
            _tagsInResource: function (tags,resource) {
                // console.log('tags',tags,resource);
                for (var t in tags) {
                    if (!resource.tags[t] || resource.tags[t] != tags[t])
                        return false;
                }
                return true;
            },
            computeRuleCategories: function (resource, rules) {
                if (!resource)
                    return RULE_CATEGORIES;
                else
                    return [{
                        name: 'on specific machines',
                        type: 'specific_machines'
                    }]
            },
            _computeMetrics: function (resource, builtinMetrics, customMetrics) {
                var metrics = [];
                for (var p in this.builtinMetrics) {
                    metrics.push(this.builtinMetrics[p])
                }
                if (this.customMetrics) {
                    for (var q in this.customMetrics) {
                        if (this.customMetrics[q].machines) {
                            var machineHasCustomMetric = this.resource && this.customMetrics[q].machines.find(function (m) {
                                return m[0] == this.resource.cloud.id && m[1] == this.resource.machine_id;
                            }, this);
                            if (machineHasCustomMetric || !this.resource)
                                metrics.push(this.customMetrics[q])
                        }
                    }
                }
                return metrics.reverse();
            },
            _hasOpenIncident: function (rule, incidents) {
                var find = false;
                find = this.incidents.find(function (i) {
                    return !i.finished_at && i.rule_id == rule.id;
                });
                return !find ? false : true;
            }
        });
    </script>
</dom-module>